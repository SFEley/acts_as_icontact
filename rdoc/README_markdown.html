<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>File: README.markdown [acts_as_icontact ]</title>

	<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet" />

	<script src="./js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="./js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>
</head>

<body class="file">
	<div id="metadata">
		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="./README_markdown.html">README.markdown</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="./images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="./ActsAsIcontact.html">ActsAsIcontact</a></li>
				
					<li><a href="./ActsAsIcontact/Account.html">ActsAsIcontact::Account</a></li>
				
					<li><a href="./ActsAsIcontact/Campaign.html">ActsAsIcontact::Campaign</a></li>
				
					<li><a href="./ActsAsIcontact/ClientFolder.html">ActsAsIcontact::ClientFolder</a></li>
				
					<li><a href="./ActsAsIcontact/Config.html">ActsAsIcontact::Config</a></li>
				
					<li><a href="./ActsAsIcontact/ConfigError.html">ActsAsIcontact::ConfigError</a></li>
				
					<li><a href="./ActsAsIcontact/Contact.html">ActsAsIcontact::Contact</a></li>
				
					<li><a href="./ActsAsIcontact/ContactHistory.html">ActsAsIcontact::ContactHistory</a></li>
				
					<li><a href="./ActsAsIcontact/CustomField.html">ActsAsIcontact::CustomField</a></li>
				
					<li><a href="./ActsAsIcontact/List.html">ActsAsIcontact::List</a></li>
				
					<li><a href="./ActsAsIcontact/Message.html">ActsAsIcontact::Message</a></li>
				
					<li><a href="./ActsAsIcontact/MessageBounces.html">ActsAsIcontact::MessageBounces</a></li>
				
					<li><a href="./ActsAsIcontact/MessageClicks.html">ActsAsIcontact::MessageClicks</a></li>
				
					<li><a href="./ActsAsIcontact/MessageOpens.html">ActsAsIcontact::MessageOpens</a></li>
				
					<li><a href="./ActsAsIcontact/MessageStatistics.html">ActsAsIcontact::MessageStatistics</a></li>
				
					<li><a href="./ActsAsIcontact/QueryError.html">ActsAsIcontact::QueryError</a></li>
				
					<li><a href="./ActsAsIcontact/Rails.html">ActsAsIcontact::Rails</a></li>
				
					<li><a href="./ActsAsIcontact/Rails/Callbacks.html">ActsAsIcontact::Rails::Callbacks</a></li>
				
					<li><a href="./ActsAsIcontact/Rails/ClassMethods.html">ActsAsIcontact::Rails::ClassMethods</a></li>
				
					<li><a href="./ActsAsIcontact/Rails/ClassMethods/Lists.html">ActsAsIcontact::Rails::ClassMethods::Lists</a></li>
				
					<li><a href="./ActsAsIcontact/Rails/ClassMethods/Macro.html">ActsAsIcontact::Rails::ClassMethods::Macro</a></li>
				
					<li><a href="./ActsAsIcontact/Rails/ClassMethods/Mappings.html">ActsAsIcontact::Rails::ClassMethods::Mappings</a></li>
				
					<li><a href="./ActsAsIcontact/ReadOnly.html">ActsAsIcontact::ReadOnly</a></li>
				
					<li><a href="./ActsAsIcontact/ReadOnlyError.html">ActsAsIcontact::ReadOnlyError</a></li>
				
					<li><a href="./ActsAsIcontact/Resource.html">ActsAsIcontact::Resource</a></li>
				
					<li><a href="./ActsAsIcontact/ResourceCollection.html">ActsAsIcontact::ResourceCollection</a></li>
				
					<li><a href="./ActsAsIcontact/SaveError.html">ActsAsIcontact::SaveError</a></li>
				
					<li><a href="./ActsAsIcontact/Segment.html">ActsAsIcontact::Segment</a></li>
				
					<li><a href="./ActsAsIcontact/SegmentCriteria.html">ActsAsIcontact::SegmentCriteria</a></li>
				
					<li><a href="./ActsAsIcontact/Subresource.html">ActsAsIcontact::Subresource</a></li>
				
					<li><a href="./ActsAsIcontact/Subscription.html">ActsAsIcontact::Subscription</a></li>
				
					<li><a href="./ActsAsIcontact/ValidationError.html">ActsAsIcontact::ValidationError</a></li>
				
					<li><a href="./ActiveRecord.html">ActiveRecord</a></li>
				
					<li><a href="./ActiveRecord/Base.html">ActiveRecord::Base</a></li>
				
					<li><a href="./Bond.html">Bond</a></li>
				
					<li><a href="./Bond/Actions.html">Bond::Actions</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<p>
<a href="ActsAsIcontact.html">ActsAsIcontact</a>
</p>
<h6>========</h6>
<p>
<a href="ActsAsIcontact.html">ActsAsIcontact</a> connects Ruby applications
with the [iContact e-mail marketing service][1] using the iContact API
v2.0. Building on the [RestClient][2] gem, it offers three significant
feature sets:
</p>
<ul>
<li>Simple, consistent access to all resources in the iContact API;

</li>
<li>A simple command-line client; and

</li>
<li>Automatic synchronizing between <a
href="ActiveRecord.html">ActiveRecord</a> models and iContact contact lists
for Rails applications.

</li>
</ul>
<p>
Prerequisites
</p>
<hr size="10"></hr><p>
You&#8217;ll need the following to use this gem properly:
</p>
<ol>
<li>**Ruby 1.9:** Yes, we know, many other gems still only work in 1.8. But <a
href="ActsAsIcontact.html">ActsAsIcontact</a> makes use of a few 1.9.1
features for efficiency, such as fiber-based Enumerators to step through
large collections without instantiating a thousand objects at once.
It&#8217;s <em>possible</em> that this might work in 1.8.7 if you install
the *<b>JSON</b>* gem and `require &#8216;enumerator&#8217;` explicitly
&#8212; but the author hasn&#8217;t tested it. If you need it to work in
1.8, speak up. Or better yet, make it work and submit a patch.

</li>
<li>**Rails 2.1 or higher:** _(If using Rails integration)_ We use
ActiveRecord&#8217;s &#8216;dirty fields&#8217; feature that first appeared
in 2.1 to determine whether iContact needs updating. If you&#8217;re on a
version of Rails older than this, it&#8217;s probably worth your while to
update anyway.

</li>
<li>**Other gems:** This gem requires the [RestClient][2], [ActiveSupport][3]
and [Bond][4] gems in order to work. Simply doing a `gem install`
<em>should</em> install these dependencies as well.

</li>
</ol>
<p>
Setting Up
</p>
<hr size="8"></hr><p>
Using <a href="ActsAsIcontact.html">ActsAsIcontact</a> is easy, but going
through iContact&#8217;s authorization process requires jumping a couple of
hoops. Here&#8217;s how to get going quickly:
</p>
<ol>
<li>Install the gem.

<pre>
    $ sudo gem install acts_as_icontact
</pre>
</li>
<li>_Optional but recommended:_ Go to <<a
href="http://sandbox.icontact.com">sandbox.icontact.com</a>> and sign up
for an iContact Sandbox account. This will let you test your app without
risk of blowing away your production mailing lists.

</li>
<li>Enable the <a href="ActsAsIcontact.html">ActsAsIcontact</a> gem for use
with your iContact account. The URL and credentials you&#8217;ll use are
different between the sandbox and production environments:

<pre>
  * **Sandbox:** Go to &lt;http://app.sandbox.icontact.com/icp/core/externallogin&gt; and enter `Ml5SnuFhnoOsuZeTOuZQnLUHTbzeUyhx` for the Application Id. Choose a password for ActsAsIcontact that's different from your account password.

  * **PRODUCTION:** Go to &lt;http://app.icontact.com/icp/core/externallogin&gt; and enter `IYDOhgaZGUKNjih3hl1ItLln7zpAtWN2` for the Application Id. Choose a password for ActsAsIcontact that's different from your account password.
</pre>
</li>
<li>Set your _(sandbox, if applicable)_ account username and the password you
just chose for API access. See the next section for how to specify these.

</li>
<li>Rinse and repeat with production credentials when you&#8217;re ready to
move out of the sandbox environment. For more information, consult the
[iContact API developer documentation][5].

</li>
</ol>
<p>
Authentication
</p>
<hr size="10"></hr><p>
<a href="ActsAsIcontact.html">ActsAsIcontact</a> already knows
iContact&#8217;s URL and its own Application Id, so the only things you
need to tell it are your username, password, and whether you want to access
the production or sandbox environments. There are three simple ways to do
that:
</p>
<ol>
<li>Set the environment variables `ICONTACT_MODE`, `ICONTACT_USERNAME`, and
`ICONTACT_PASSWORD`. The `ICONTACT_MODE` environment variable should have a
value of either <em>production</em> or <em>sandbox</em>.

</li>
<li>Create a directory called *<b>.icontact</b>* under your home directory and
place a YAML file in it titled *<b>config.yml</b>*:

<pre>
     ---
     mode: production
     username: my_username
     password: my_password
 This hidden directory is also used for the command line client's history file, and future versions of ActsAsIcontact may use it for caching.
</pre>
</li>
<li>You can explicitly set them anywhere in your code with calls to the Config
module (note that the mode is a symbol, not a string):

<pre>
     require 'rubygems'
     require 'acts_as_icontact'

     ActsAsIcontact::Config.mode = :sandbox
     ActsAsIcontact::Config.username = &quot;my_sandbox_username&quot;
     ActsAsIcontact::Config.password = &quot;my_api_password&quot;

 If you're using Rails, the recommended approach is to require the gem with `config.gem 'acts_as_icontact'` in your **config/environment.rb** file, and then set up an initializer (i.e. **config/initializers/acts\_as\_icontact.rb**) with the above code.  See more about Rails below.
</pre>
</li>
</ol>
<p>
Using the API
</p>
<hr size="10"></hr><p>
Whether or not you&#8217;re using Rails, retrieving and modifying iContact
resources is simple. The gem autodiscovers your account and client folder
IDs (you only have one of each unless you&#8217;re an &#8216;agency&#8217;
account), so you can jump straight to the good parts:
</p>
<pre>
     contacts = ActsAsIcontact::Contact.find(:all)  # =&gt; &lt;#ActsAsIcontact::ResourceCollection&gt;
     c = contacts.first    # =&gt; &lt;#ActsAsIcontact.Contact&gt;
     c.firstName           # =&gt; &quot;Bob&quot;
     c.lastName            # =&gt; &quot;Smith&quot;
     c.email               # =&gt; &quot;bob@example.org&quot;
     c.lastName = &quot;Smith-Jones&quot;   # Bob gets married and changes his name
     c.save                # =&gt; true
     history = c.actions   # =&gt; &lt;#ActsAsIcontact::ResourceCollection&gt;
     a = history.first     # =&gt; &lt;#ActsAsIcontact::Action&gt;
     a.actionType          # =&gt; &quot;EditFields&quot;
</pre>
<p>
### Nesting The interface is deliberately as
&#8220;ActiveRecord-like&#8221; as possible, with methods linking resources
that are either nested in iContact&#8217;s URLs or logically related.
Messages have a Message#bounces method. Lists have `List#subscribers` to
list the Contacts subscribed to them, and Contacts have `Contact#lists`.
Read the [documentation][5] for each class to find out what you can do:
</p>
<ul>
<li><a href="ActsAsIcontact/Account.html">ActsAsIcontact::Account</a>

<ul>
<li><a href="ActsAsIcontact/ClientFolder.html">ActsAsIcontact::ClientFolder</a>

</li>
</ul>
</li>
<li><a href="ActsAsIcontact/Contact.html">ActsAsIcontact::Contact</a>

<ul>
<li>ActsAsIcontact::History _(documented as &#8220;Contact History&#8221;)_

</li>
</ul>
</li>
<li><a href="ActsAsIcontact/Message.html">ActsAsIcontact::Message</a>

<ul>
<li>ActsAsIcontact::Bounce

</li>
<li>ActsAsIcontact::Click

</li>
<li>ActsAsIcontact::Open

</li>
<li>ActsAsIcontact::Unsubscribe

</li>
<li>ActsAsIcontact::Statistics

</li>
</ul>
</li>
<li><a href="ActsAsIcontact/List.html">ActsAsIcontact::List</a>

<ul>
<li><a href="ActsAsIcontact/Segment.html">ActsAsIcontact::Segment</a>

<pre>
  * ActsAsIcontact::Criterion  _(documented as &quot;Segment Criteria&quot;)_
</pre>
</li>
</ul>
</li>
<li><a href="ActsAsIcontact/Subscription.html">ActsAsIcontact::Subscription</a>

</li>
<li><a href="ActsAsIcontact/Campaign.html">ActsAsIcontact::Campaign</a>

</li>
<li><a href="ActsAsIcontact/CustomField.html">ActsAsIcontact::CustomField</a>

</li>
<li>ActsAsIcontact::Send

</li>
<li>ActsAsIcontact::Upload

</li>
<li>ActsAsIcontact::User

<ul>
<li>ActsAsIcontact::Permission

</li>
</ul>
</li>
<li>ActsAsIcontact::Time

</li>
</ul>
<p>
### Searching Searches are handled using the same query options that
iContact accepts, but with a syntax based on <a
href="ActiveRecord.html">ActiveRecord</a>. At this time, special searches
(i.e. <em>gte</em>, <em>bet</em> etc.) are not yet supported. Fields
requiring dates must be given a string corresponding to the ISO8601
timestamp (e.g. `2006-09-16T14:30:00-06:00`); proper date/time conversion
will happen soon. See the [iContact developer docs][5] for available search
options.
</p>
<p>
The following class methods are offered (using the Message class as an
example):
</p>
<p>
#### Message.first
</p>
<p>
Returns a single Message. With no parameters, it returns the first Message
in iContact&#8217;s system, which may be arbitrary. You can specify one or
more search parameters as an options hash (note the Ruby 1.9 syntax):
</p>
<pre>
    Message.first(messageType: &quot;welcome&quot;)  # =&gt; The first welcome message
    Message.first(orderby: &quot;createDate:desc&quot;)  # =&gt; Most recent message
</pre>
<p>
If no records can be found matching the parameters, the *<b>first</b>*
method returns nil.
</p>
<p>
#### Message.all
</p>
<p>
Returns a collection of Messages matching the search parameters. The
<em>limit</em> and <em>offset</em> parameters are important here; if no
<em>limit</em> is provided, a default limit of 500 records is used. (That
default is also the maximum, at the request of iContact&#8217;s technical
staff.)
</p>
<p>
The collection is an object of type ResourceCollection, and it acts both as
an array and an enumerator. For efficiency, individual Message objects are
instantiated only when you access them.
</p>
<pre>
    Message.all(messageType: &quot;confirmation&quot;)  # =&gt; All confirmation messages (up to 500)
    Message.all(limit: 20)  # =&gt; The first 20 messages
    Message.all(limit: 20, offset: 40)  # =&gt; Messages 41-60
    Message.all(offset:500)  # =&gt; Messages 501-1000

    # Example of collection iteration
    @messages = Message.all  # =&gt; Assigns the first 500 messages to @messages
    @messages.count  # =&gt; Number of messages
    @messages[11]    # =&gt; Twelfth message in the collection (arrays are 0-based)
    @messages.first  # =&gt; First message
    @messages.next   # =&gt; Second message
    @messages.next   # =&gt; Third message (et cetera)
</pre>
<p>
If no records can be found matching the parameters, the *<b>all</b>* method
returns nil.
</p>
<p>
#### Message.find
</p>
<p>
Like its <a href="ActiveRecord.html">ActiveRecord</a> role model, find has
several behaviors depending on its parameter list:
</p>
<pre>
    Message.find(:first, messageType: &quot;welcome&quot;)  # =&gt; Identical to Message.first(messageType: &quot;welcome&quot;)
    Message.find(:all, limit: 20)  # =&gt; Identical to Message.all(limit: 20)
    Message.find(7)  # =&gt; Single Message found with messageId of 7
    Message.find(&quot;foo&quot;)  # =&gt; Single Message found with subject of &quot;foo&quot;
</pre>
<p>
The <em>integer</em> and <em>string</em> parameter modes warrant some
explanation. Passing an integer to *<b>find</b>* on most resource classes
will do a primary key lookup. So Accounts will match on the accountId,
Contacts will match on the contactId, etc. The integer variant is
unsupported for the CustomField and Subscription classes, which use
string-based primary keys.
</p>
<p>
Passing a string to *<b>find</b>* on most resource classes will do a
single-record search based on the field most likely to be unique and
important:
</p>
<ul>
<li>*<b>Account:</b>* userName

</li>
<li>*<b>Campaign:</b>* name

</li>
<li>*<b>ClientFolder:</b>* name

</li>
<li>*<b>Contact:</b>* email

</li>
<li>*<b>CustomField:</b>* customFieldId _(primary key)_

</li>
<li>*<b>List:</b>* name

</li>
<li>*<b>Message:</b>* subject

</li>
<li>*<b>Segment:</b>* name

</li>
<li>*<b>Subscription:</b>* subscriptionId _(primary key)_

</li>
<li>*<b>User:</b>* userName

</li>
</ul>
<p>
If no records can be found using *<b>find</b>*, the <em>:first</em> and
<em>:all</em> variants will return nil (just like *<b>first</b>* and
*<b>all</b>*). The <em>integer</em> and <em>string</em> variants will
return an exception, on the assumption that you knew exactly what you were
looking for and expected it to be there. (I.e., matching the behavior of <a
href="ActiveRecord.html">ActiveRecord</a>.)
</p>
<p>
### Updating
</p>
<p>
Again, think <a href="ActiveRecord.html">ActiveRecord</a>. When you
initialize an object, you can optionally pass it a hash of values:
</p>
<pre>
    c = Contact.new(:firstName =&gt; &quot;Bob&quot;,
                    :lastName =&gt; &quot;Smith-Jones&quot;,
                    :email =&gt; &quot;bob@example.org&quot;)
    c.address = &quot;123 Test Street&quot;
</pre>
<p>
Each resource object has a *<b>save</b>* method which returns true or
false. If false, the *<b>error</b>* method contains the reply back from
iContact about what went wrong. (Which may or may not be informative, but
we can&#8217;t tell you more than they do.) There&#8217;s also a
*<b>save!</b>* method which throws an exception on failure instead of
returning false.
</p>
<p>
Nested resources can be created using the **build_foo** method (which
returns an object but doesn&#8217;t save it right away) or **create_foo**
method (which does save it upon creation). The full panoply of <a
href="ActiveRecord.html">ActiveRecord</a> association methods are not
implemented yet. (Hey, we said it was AR-<em>like.</em>)
</p>
<p>
The *<b>delete</b>* method on each object works as you&#8217;d expect,
assuming iContact allows deletes on that resource. Resource collections
containing the resource are not updated, however, so you may need to
requery.
</p>
<p>
Multiple-record updates are not implemented at this time.
</p>
<p>
Rails Integration
</p>
<hr size="10"></hr><p>
The <em>real</em> power of <a href="ActsAsIcontact.html">ActsAsIcontact</a>
is its automatic syncing with <a href="ActiveRecord.html">ActiveRecord</a>.
At this time this feature is focused entirely on Contacts.
</p>
<p>
### Activation First add the line `config.gem
&#8216;acts_as_icontact&#8217;` to your *<b>config/environment.rb</b>*
file. Then create an initializer (e.g.
**config/initializers/acts_as_icontact.rb**) and set it up with your
username and password. If applicable, you can give it both the sandbox
<em>and</em> production credentials:
</p>
<pre>
    module ActsAsIcontact
      case Config.mode
                        when :sandbox
        Config.username = my_sandbox_username
        Config.password = my_sandbox_password
      when :production
        Config.username = my_production_username
        Config.password = my_production_password
      end
    end
</pre>
<p>
If <a href="ActsAsIcontact.html">ActsAsIcontact</a> detects that it&#8217;s
running in a Rails app, the default behavior is to set the mode to
`:production` if RAILS_ENV is equal to &#8220;production&#8221; and
`:sandbox` if RAILS_ENV is set to anything else. (Incidentally, if
you&#8217;re <em>not</em> in a Rails app but running Rack, the same logic
applies for the RACK_ENV environment variable.)
</p>
<p>
Finally, enable one of your models to synchronize with iContact with a
simple declaration:
</p>
<pre>
    class Person &lt; ActiveRecord::Base
      acts_as_icontact
    end
</pre>
<p>
There are some options, of course; we&#8217;ll get to those in a bit.
</p>
<p>
### What Happens When you call the `acts_as_icontact` method in an <a
href="ActiveRecord.html">ActiveRecord</a> class declaration, the gem does
several useful things:
</p>
<ol>
<li>Creates callbacks to post changes to iContact&#8217;s API after a record is
saved or deleted.

</li>
<li>Defines an `icontact_sync!` method to pull the contact&#8217;s data
<em>from</em> iContact and make any changes.

</li>
<li>Defines other methods such as `icontact_lists` and `icontact_history` to
make related data accessible.

</li>
<li>If an `icontact_status` field exists, creates named scopes on the model
class for each iContact status. _(Pending)_

</li>
</ol>
<p>
### Options Option values and field mappings can be passed to the
`acts_as_icontact` declaration to set default behavior for the model class.
</p>
<p>
`list` &#8212; _The name or ID number of a list to subscribe new contacts
to automatically_ `lists` &#8212; _Like `list` but takes an array of names
or numbers; new contacts will be subscribed to all of them_
`exception_on_failure` &#8212; _If true, throws an
ActsAsIcontact::SyncError when synchronization fails. Defaults to false._
</p>
<p>
A note about failure: problems with synchronization are always logged to
the standard Rails log. For most applications, however, updating iContact
is a secondary consideration; if a new user is registering, you
<em>probably</em> don&#8217;t want exceptions bubbling up and the whole
transaction rolling back just because of a transient iContact server
outage. So exceptions are something you have to deliberately enable.
</p>
<p>
### Field Mappings You can add contact integration to any <a
href="ActiveRecord.html">ActiveRecord</a> model that tracks an email
address. (If your model _doesn&#8217;t_ include email but you want to use
iContact with it, you are very, very confused.)
</p>
<p>
Any fields that are named the same as iContact&#8217;s personal information
fields, or custom fields you&#8217;ve previously declared, will be
autodiscovered. Otherwise you can map them:
</p>
<pre>
    class Customer &lt; ActiveRecord::Base
      acts_as_icontact :lists =&gt; ['New Customers', 'All Users']  # Puts new contact on two lists
                       :firstName =&gt; :given_name, # Key is iContact field, value is Rails field
                       :lastName =&gt; :family_name,
                       :street =&gt; :address1,
                       :street2 =&gt; :address2,
                       :rails_id =&gt; :id  # Custom field created in iContact
                       :preferred_customer =&gt; :preferred? # Custom field
    end
</pre>
<p>
A few iContact-specific fields are exceptions, and have different
autodiscovery names to avoid collisions with other attributes in your
application:
</p>
<p>
`icontact_id` &#8212; _Corresponds to `contactId` in iContact. Highly
recommended._ `icontact_status` &#8212; _Corresponds to `status` in
iContact._ `icontact_created` &#8212; _Corresponds to `createDate` in
iContact._ `icontact_bounces` &#8212; _Corresponds to `bounceCount` in
iContact._
</p>
<p>
You are welcome to create these fields in your model or omit them. However,
we <em>strongly</em> recommend that you either include the `icontact_id`
field to track iContact&#8217;s primary key in your application, or map
your own model&#8217;s primary key to a custom field in iContact. You can
also do both for two-way associations. If you don&#8217;t establish a
relationship with at least one ID, <a
href="ActsAsIcontact.html">ActsAsIcontact</a> will resort to using the
email address for lookups &#8212; which will be a problem if the email
address changes.
</p>
<p>
### Lists The reason to add contacts to iContact is to put them on mailing
lists. We know this. The `default_list` option (see above) is one way to do
it automatically. The following methods are also defined on the model for
your convenience:
</p>
<p>
`icontact_lists` &#8212; _An array of List objects to which the contact is
currently subscribed_ `icontact_subscribe(list)` &#8212; _Given a list name
or ID number, subscribes the contact to that list immediately_
`icontact_unsubscribe(list)` &#8212; _Given a list name or ID number,
unsubscribes the contact from that list_
</p>
<p>
### Why Just Contacts? iContact&#8217;s interface is really quite good at
handling pretty much every other resource. Campaigns, segments, etc. can
usually stand alone. It&#8217;s less likely that you&#8217;ll need to keep
copies of them in your Rails app. But contacts are highly entangled. If
you&#8217;re using iContact to communicate with your app&#8217;s users or
subjects, you&#8217;ll want to keep iContact up-to-date when they change.
And if someone bounces or unsubscribes in iContact, odds are good
you&#8217;ll want to know about it. So this is the strongest point of
coupling and the highest priority feature. (Lists will likely come next,
followed by messages.)
</p>
<p>
Copyright
</p>
<hr size="7"></hr><p>
Copyright &#169; 2009 Stephen Eley. See LICENSE for details.
</p>
<p>
[1]: <a href="http://icontact.com">icontact.com</a> &#8220;iContact&#8221;
[2]: <a href="http://rest-client.heroku.com">rest-client.heroku.com</a>
&#8220;Rest-Client&#8221; [3]: <a
href="http://as.rubyonrails.org/">as.rubyonrails.org/</a>
&#8220;ActiveSupport&#8221; [4]: <a
href="http://tagaholic.me/bond">tagaholic.me/bond</a> &#8220;Bond&#8221;
[5]: <a href="http://developer.icontact.com/">developer.icontact.com/</a>
&#8220;iContact Developer Portal&#8220;
</p>

	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>
</body>
</html>

